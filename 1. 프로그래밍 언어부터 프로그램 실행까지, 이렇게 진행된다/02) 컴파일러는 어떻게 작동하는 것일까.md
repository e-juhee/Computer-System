컴파일러가 무엇을 묵묵히 ㅋㅋ 해내고 있는지 알고 계십니까?!?!

---

# 1.2.1 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다
- 컴파일러가 뭐임?
  - 고수준 언어를 저수준 언어로 번역하는 프로그램
  - 컴파일러도 결국 프로그램에 불과하다.
- 소스 파일(코드가 작성된 텍스트 파일 형태의 파일)을 컴파일러에게 먹이로 주면 실행 파일 형태로 뱉어낸다.
- 이 실행 파일에 CPU가 직접 실행할 수 있는 기계 명령어가 저장되어 있다.

컴파일러는 이걸 어떤 과정을 거쳐서 바꿔주는 걸까?

- 컴파일러는 크게 보면 번역기, 작게 보면 텍스트 처리 프로그램(text processor)이다.

# 1.2.2 각각의 토큰 추출하기
- 먼저 각 항목을 잘게 쪼갠다.
- 이때 각 항목이 가지고 있는 추가 정보를 함께 묶어서 관리한다.
- 각 항목에 추가로 정보를 결합한 것을 **토큰**이라고 한다.
  - 추가 정보: 토큰의 의미와 토큰이 가지는 값
  - ex) 토큰의 의미 T_Keyword, 토큰이 가지는 값 int
- 컴파일러가 하는 첫 번째 작업은 소스 코드를 돌아다니면서 모든 토큰을 찾아내는 것!
- 이렇게 소스 코드에서 토큰을 추출하는 과정을 **어휘 분석(lexical analysis)**라고 한다.

# 1.2.3 토큰이 표현하고자 하는 의미

```c
while (표현식) 
{
  반복 내용
}
```

- 컴파일러가 `while` 키워드의 토큰을 찾으면 다음 토큰이 `(`라는 것을 알고 있는 상태로 기다리게 된다.
- 다음 토큰이 `while` 키워드에 필요한 토큰이 아니라면 문법 오류(syntax error)를 보고한다.
- 이 과정을 무사히 넘어가면 다음 토큰이 `bool` 표현식이어야 한다는 것으 알고 기다린다.
- 다음으로 `)`, `{`를 거쳐 마지막에 `}`를 만날 때까지 계속 기다리고 처리하는 과정을 반복한다.
- 이런 과정을 **해석(Parsing)**이라고 한다.
- 이렇게 구문에 따라 해석해 낸 구조는 트리로 표현한다.
- 구문 규칙에 따라 토큰을 해석한 후 생성된 트리가 **구문 트리**
- 이 트리를 생성하는 전체 과정을 **구문 분석**이라고 한다.