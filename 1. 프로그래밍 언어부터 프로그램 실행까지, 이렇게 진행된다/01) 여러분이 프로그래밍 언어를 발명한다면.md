소프트웨어 ~ 하드웨어, 고수준 계층 ~ 저수준 계층까지 컴퓨터 시스템 내부를 알아볼 것이다.  
가장 먼저, 프로그래머가 코드를 작성할 때 어떤 일이 일어나는지 살펴볼 것이고  
이 책을 다 읽고 나면 프로그래밍 언어는 컴퓨터 과학의 매우 작은 부분에 불과한다는 것을 알게 될 것이다.  
(프로그래밍 언어는 컴퓨터에 명령을 내리는 도구일 뿐이다.)  

컴퓨터는 코드를 어떻게 인식하는 것일까?  

```
코드를 기반으로 컴파일러가 실행 파일을 생성하면 그 프로그래밍 실행된다.
```
👆 이것은 정확한 표현이지만 너무 광범위하다.  

아래의 질문들이 이 책 전체에 걸쳐 제기될 것이다.  

- 컴파일러는 어떻게 코드를 기반으로 실행 파일을 생성(build)할까?
- 프로그래밍 언어는 어떻게 만들었을까?
- 실행 파일은 왜 실행될 수 있을까?
- 실행 파일은 어떤 형태로 어떻게 실행될까?
- 실행되고 나면 어떤 형태를 갖추지?
- 더 효율적으로 실행할 방법은?

우선 프로그래밍 언어부터 알아보자  
프로그래밍 언어를 깊이 이해하는 가장 좋은 방법은 프로그래밍 언어를 만들어 보는 것이다.  

프로그래밍 언어를 발명하라는 요청을 받으면 어떻게 해야 할까?  

---

# 1.1 여러분이 프로그래밍 언어를 발명한다면?
- 간단한 스위치를 조합하면 복잡한 boolean 논리를 표현할 수 있다는 사실을 발견하고, 이를 기반으로 CPU가 만들어졌다.
    - 따라서 CPU는 간단한 on-off만 이해한다.

## 1.1.1 창세기: CPU는 똑똑한 바보
- CPU는 데이터를 한곳에서 다른 곳으로 옮기고 간단히 연산한 후 다시 그 데이터를 또 다른 자리로 옮기는 작업 외에는 할 줄 모른다.
- 하지만 무엇과도 비교할 수 없이 엄청나게 빠르다는 장점이 있다.
    - 이 빠른 속도는 CPU의 멍청함을 상쇄하고도 남는다.
- CPU와 의사소통을 하기 위해 천공 카드(punched card)를 이용해서 컴퓨터 작업을 제어했다.
    - 직접 0과 1로 구성된 명령어를 작성했다.

## 1.1.2 어셈블리어 등장
- CPU가 가산 명령어, 점프 명령어 등 **겨우 몇 가지 명령어**만 실행할 수 있다는 사실을 발견하게 된다!
- 기계어와 해당 특정 작업을 대응시켜 인간이 읽고 이해할 수 있는 단어와 대응시켰다.
- 인간이 인식할 수 있는 이 기계 명령어를 CPU가 인식할 수 있는 0과 1로 구성된 바이너리로 변환하는 프로그램을 사용했다.
- 이것이 바로 어셈블리어

## 1.1.3 저수준 계층의 세부 사항 VS 고수준 계층의 추상화
- 어셈블리어는 기계어와 마찬가지로 여전히 저수준 언어이다.
- CPU는 단순하기 때문에 명령을 조금만 추상적으로 바꾸어도 이해하지 못하는 반면 인간은 추상적인 표현에 익숙하다.
- 인간의 추상적인 표현을 CPU가 이해하는 구체적인 구현으로 자동으로 변환할 수 있다면 생산성을 획기적으로 높일 수 있을 것이다.

## 1.1.4 가득한 규칙: 고급 프로그래밍 언어의 시작
- 어떻게 인간의 추상적인 표현을 CPU가 이해할 수 있는 구체적인 구현으로 자동 변환할 수 있을까?
- CPU에게 내리는 명령어에 문(statement) 또는 문장이라는 이름을 붙였다.
- CPU가 이해하는 세부 사항이 규칙 또는 패턴으로 가득하다는 것을 발견했다.
    - 조건에 따른 이동: 특정 상황에 따라 어떤 명령을 실행할지 결정해야 하는 선택이 필요한 경우 -> if문
    - 순환: 일정한 명령어를 계속 반복하는 경우 -> while문
    - 함수: 반복되는 명령어 -> function

## 1.1.5 <인셉션>과 재귀: 코드 본질
- 대부분의 코드는 단도직입적인 문장이지만, 전부 그렇지는 않다.
- 명령 안에 if문이 포함될 수 있고 그 안에 또 명령, 또 그 안에 if문... 자식과 손자 관계가 끝없이 이어질 수 있다. 인셉션 영화 처럼..
- 여기에 재귀라는 개념을 더한다.
    ```
    f(x) = f(x-1) + f(x-2)
    ```
    - f(x)는 f(x-1)에 의존하고, f(x-1)은 다시 f(x-2)와 f(x-3)에 의존한다.
    - 끝없이 중첩된 것처럼 보이는 것을 재귀로 표현할 수 있다!!
- 단계가 또 다른 단계에 중첩되는 <인셉션>을 간결한 문장 몇 개로 표현할 수 있게 되었다.
    - 이 몇 가지 표현에 구문(syntax)라는 간지나는 이름을 붙인다.
    ```
    if: if expr statement else statement
    for: while expr statement
    statement: if | for | statement
    ```
- 세상의 모든 코드는 아무리 복잡하더라도 결과적으로는 모두 구문으로 귀결된다.
    - 모든 코드는 구문에 기초하여 작성되기 때문이다.

## 1.1.6 컴퓨터가 재귀를 이해하도록 만들기
- 이제 다음 문제는 프로그래밍 언어를 컴퓨터가 인식할 수 있는 기계 명령어로 변환하는 방법을 찾는 것!
- 인간은 구문에 따라 코드를 작성할 수 있는데, 이 코드는 문자열에 불과하다..
- 컴퓨터가 재귀 구문으로 표현된 문자열을 인식할 수 있게 하려면 어떻게 해야 할까?
- 이번에는 나뭇가지에 잎이나 나뭇가지가 이어지는 트리 구조를 활용한다.
    - 단계 안에 단계가 중첩되고 꿈속의 꿈, 끝 없는 자식 관계... -> 즉, 이것도 재귀
- 재귀 구문에 따라 작성된 코드를 표현할 수 있는 것!

## 1.1.7 우수한 번역가: 컴파일러
- 이제 코드를 트리 형태로 표현할 수 있게 되었다.
- leaf node를 기계 명령어로 번역하기만 하면 결과를 그 leaf node의 부모 노드에 적용할 수 있다.
- 이렇게 번역 결과를 차례대로 부모 노드에 적용하는 방식으로 올라가다 보면 결국 전체 트리를 구체적인 기계 명령어로 번역할 수 있다.
- 이러한 작업을 담당하는 프로그램에게 compiler라는 이름을 붙였다.

# 1.1.8 해석형 언어의 탄생
- 또다른 문제: CPU마다 이해하는 기계 명령어 형식이 다르다..ㅠㅠ (CPU마다 각각 자신만의 고유한 언어가 있다)
    - x86 플랫폼용으로 생성한 실행 파일을 ARM 플랫폼에서 직접 실행할 방법이 없는 것과 같다.
- 영어가 국제 통용어로 사용되듯, 표준 명령어 집합을 정의해서 CPU의 기계 명령어 실행 과정을 모방하는 프로그램을 작성하여 사용하게 된다.
- 이제 각 CPU마다 상응하는 시뮬레이션 프로그램으로 서로 다른 플랫폼에서 코드를 실행할 수 있게 되었다.
- 이 CPU 시뮬레이션 프로그램의 이름이 virtual machine이고, interpreter라고도 부른다.
- 이 아이디어(인터프리터가 실행 코드를 해석해줌)를 바탕으로 C/C++, 자바, 파이썬 등 프로그래밍 언어가 만들어졌다.
- 코드를 해석하고 실행하는 과정
  - 세상의 모든 프로그래밍 언어는 특정 구문에 따라 작성된다.
  - 언어 구문에 따라 코드 구문을 분석해서 구문 트리로 만들고
  - C/C++ 언어인 경우, 기계 명령어로 번역 후 CPU에 전달
  - 자바는 바이트 코드로 변환 후 가상 머신으로 전달해서 실행한다.
- 고급 언어의 한계
  - 고급 언어는 추상적 표현이 뛰어나서 사용하기 쉽지만
  - **저수준 계층에 대한 제어 능력**이 떨어진다..
  - 따라서 저수준 계층의 세부 사항을 제어할 수 있어야 하는 운영 체제 중 일부분은 어셈블리어로 작성된다.